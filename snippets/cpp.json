{
  "Seg-tree": {
    "prefix": "segt",
    "body": [
      "int n, m, p;",
      "int a[N];",
      "namespace Seg_T {",
      "    long long s[N << 2], c[N << 2], v[N << 2];",
      "    inline void build ( int k, int l, int r ) {",
      "        c[k] = 1;",
      "        if ( l == r ) { s[k] = a[l]; return; }",
      "        int mid = l + r >> 1;",
      "        build ( k << 1, l, mid ), build ( k << 1 | 1, mid + 1, r );",
      "        ( s[k] = s[k << 1] + s[k << 1 | 1] ) %= p;",
      "    } inline void pushdown ( int k, int l, int r ) {",
      "        int mid = l + r >> 1;",
      "        c[k << 1] = c[k << 1] * c[k] % p;",
      "        c[k << 1 | 1] = c[k << 1 | 1] * c[k] % p;",
      "        v[k << 1] = ( v[k << 1] * c[k] + v[k] ) % p;",
      "        v[k << 1 | 1] = ( v[k << 1 | 1] * c[k] + v[k] ) % p;",
      "        s[k << 1] = ( s[k << 1] * c[k] + ( mid - l + 1 ) * v[k] ) % p;",
      "        s[k << 1 | 1] = ( s[k << 1 | 1] * c[k] + ( r - mid ) * v[k] ) % p;",
      "        c[k] = 1, v[k] = 0;",
      "    } inline void update1 ( int k, int l, int r, int x, int y, int q ) {",
      "        if ( r < x || l > y ) return;",
      "        if ( x <= l && r <= y ) {",
      "            s[k] = ( s[k] * q ) % p;",
      "            v[k] = ( v[k] * q ) % p;",
      "            c[k] = ( c[k] * q ) % p;",
      "            return;",
      "        } int mid = l + r >> 1;",
      "        pushdown ( k, l, r );",
      "        update1 ( k << 1, l, mid, x, y, q ), update1 ( k << 1 | 1, mid + 1, r, x, y, q );",
      "        s[k] = ( s[k << 1] + s[k << 1 | 1] ) % p;",
      "    } inline void update2 ( int k, int l, int r, int x, int y, int q ) {",
      "        if ( r < x || l > y ) return;",
      "        if ( x <= l && r <= y ) {",
      "            s[k] = ( s[k] + ( r - l + 1 ) * q ) % p;",
      "            v[k] = ( v[k] + q ) % p;",
      "            return;",
      "        } int mid = l + r >> 1;",
      "        pushdown ( k, l, r );",
      "        update2 ( k << 1, l, mid, x, y, q ), update2 ( k << 1 | 1, mid + 1, r, x, y, q );",
      "        s[k] = ( s[k << 1] + s[k << 1 | 1] ) % p;",
      "    } inline int query ( int k, int l, int r, int x, int y ) {",
      "        if ( r < x || l > y ) return 0;",
      "        if ( x <= l && r <= y ) return s[k];",
      "        int mid = l + r >> 1;",
      "        pushdown ( k, l, r );",
      "        return 1ll * ( query ( k << 1, l, mid, x, y ) + query ( k << 1 | 1, mid + 1, r, x, y ) ) % p;",
      "    }",
      "}",
      ""
    ],
    "description": "Seg-tree"
  }
}
